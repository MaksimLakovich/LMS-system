# LMS API (Django REST Framework)

---

[1. Цель проекта](#title1) / 
[2. Модели](#title2) / 
[3. Админки](#title3) / 
[4. Сериализации](#title4) / 
[5. Валидация](#title5) / 
[6. Контроллеры](#title6) / 
[7. Права доступов](#title7) / 
[8. Пагинация](#title8) / 
[9. Интеграция с платежной системой (сервисные функции)](#title9) / 
[10. Вспомогательные функции](#title10) / 
[11. Сигналы](#title11) / 
[12. Отложенные задачи](#title12) / 
[13. Загрузка тестовых данных](#title13) / 
[14. Тестирование приложения](#title14) / 
[15. Получение ключей .env](#title15) / 
[16. Получение ключей .env.docker](#title16) / 
[17. Описание файла .flake8](#title17) / 
[18. Описание файла mypy.ini](#title18) / 
[19. Документация к API](#title19) / 
[20. Локальная установка проекта](#title20) / 
[21. Установка и запуск проекта на сервере (через Docker и Nginx)](#title21) / 
[22. Автоматический деплой через GitHub Actions](#title22) /

---

# <a id="title1">1. Цель проекта</a>
Backend для разработки LMS-системы (онлайн-платформы обучения), в которой каждый желающий сможет размещать свои полезные материалы или курсы.
Разработка выполнена над SPA веб-приложением и результатом создания проекта будет бэкенд-сервер, который возвращает клиенту JSON-структуры.

---

# <a id="title2">2. Описание моделей (models)</a>

## _Приложение "Users" (users/models.py):_

1) Модель данных `CustomUser(AbstractUser)` - представляет Пользователя на платформе для онлайн-обучения (авторизация по email):
   - Наследуется от модели **AbstractUser**, которая является готовой моделью и включает все основные поля и методы, такие как username, email, first_name, last_name, is_staff, is_active и другие.
   - ***Дополнительно определил:***
     - ник пользователя (username);
     - эл.почта пользователя (email);
     - телефон пользователя (phone_number);
     - город пользователя (city);
     - аватар пользователя (avatar).

2) Модель данных `Payments(models.Model)`- представляет платежи за Lesson и/или за Course на платформе для онлайн-обучения:
   - пользователь (user).
   - дата и время оплаты (payment_date).
   - оплаченный курс (paid_course).
   - оплаченный урок (paid_lesson).
   - сумма платежа (payment_amount).
   - метод платежа (payment_method).
   - статус платежа (payment_status).
   - ID созданного продукта в платежной системе Stripe (stripe_product_id).
   - ID созданной цены в платежной системе Stripe (stripe_price_id).
   - ID созданной сессии для получения ссылки на оплату в платежной системе Stripe (stripe_session_id).
   - Ссылка на оплату продукта (payment_url).

## _Приложение "lms_system" (lms_system/models.py):_

1) Абстрактная модель данных `TimeStampedModel(models.Model)` - абстрактная базовая модель для дальнейшего создания *created_at* и *updated_at* во всех моделях приложения:
   - *Поля модели:*
     - дата создания (created_at).
     - дата обновления (updated_at).

2) Модель данных `Course(TimeStampedModel)` - представляет Курс на платформе для онлайн-обучения:
   - *Наследование:*
     - наследуется от абстрактной базовой модели TimeStampedModel для добавления created_at и updated_at по умолчанию.
   - *Поля модели:*
     - название курса (title).
     - превью курса (preview).
     - описание курса (description).
     - владелец курса (owner).

2) Модель данных `Lesson(TimeStampedModel)` - представляет Урок на платформе для онлайн-обучения:
   - *Наследование:*
     - наследуется от абстрактной базовой модели TimeStampedModel для добавления created_at и updated_at по умолчанию.
   - *Поля модели:*
     - курс урока (course).
     - название урока (title).
     - описание урока (description).
     - превью урока (preview).
     - ссылка на видео урока (video_url).
     - владелец урока (owner).

3) Модель данных `Subscription(models.Model)` - представляет Подписку на обновление курса (Course) для пользователя (CustomUser):
   - *Поля модели:*
     - курс на который подписка (course).
     - подписчик (user).

---

# <a id="title3">3. Описание админок (admin)</a>

## _Приложение "Users" (users/admin.py):_

1) Админка `CustomUserAdmin(UserAdmin)` - отображение данный модели Пользователя (CustomUser) в админке.

2) Админка `PaymentsAdmin(admin.ModelAdmin)` - отображение данных модели Платежи (Payments) в админке.

## _Приложение "lms_system" (lms_system/admin.py):_

1) Админка `CourseAdmin(admin.ModelAdmin)` - отображение данных модели Курса (Course) в админке.

2) Админка `LessonAdmin(admin.ModelAdmin)` - отображение данных модели Урока (Lesson) в админке.

3) Админка `SubscriptionAdmin(admin.ModelAdmin)` - отображение данных модели Подписки (Subscription) в админке.

---

# <a id="title4">4. Описание сериализаций (serializers)</a>

## _Приложение "Users" (users/serializers.py):_

1) Сериализатор `CustomUserSerializer(serializers.ModelSerializer)` - класс-сериализатор с использованием класса ModelSerializer для осуществления базовой сериализация в DRF на основе модели CustomUser. Описывает то, какие поля модели CustomUser будут участвовать в сериализации и десериализации.
   - Кастомизация сериализатора:
     - поле `payments` - с помощью сериализатора для связанной модели *Payments* (**PaymentsSerializer(many=True, read_only=True)**) вывод детальной информации по всем платежам пользователя, где:
       - ***many=True*** - параметр указывает, что это поле является связью "один ко многим" и может содержать несколько записей.
       - ***read_only=True*** - параметр указывает, что поле только для чтения и НЕ будет ожидаться на входе в запросах POST/PUT.
     - `create(self, validated_data)` - переопределение метода создания пользователя, чтобы пароль сохранялся БД в хэшированном виде.
     - `to_representation(instance)` - возвращает сериализованное представление пользователя.
       - Если запрашивающий пользователь смотрит "свой профиль", то отображаются все поля.
       - Если запрашивающий пользователь смотрит "чужой профиль", то скрываются конфиденциальные поля:
         - last_name (фамилия)
         - payments (история платежей)
         - password (в любом случае не нужен в ответе)
       - Используется для динамической настройки отображения данных в зависимости от прав доступа.
   - Дополнительные параметры Meta-класса:
     - параметр `extra_kwargs` - зарезервированное имя параметра в Meta-классе ModelSerializer для настройки конкретных полей, например, ниже указываю что пароль только на ЗАПИСЬ. Т.е. его можно отправить через POST/PUT/PATCH, но он не будет отображаться в ответе API (GET, LIST и т.п.).
     ```python
     extra_kwargs = {
        "password": {"write_only": True},
     }
     ```

2) Сериализатор `PaymentsSerializer(serializers.ModelSerializer)` - класс-сериализатор с использованием класса ModelSerializer для осуществления базовой сериализация в DRF на основе модели Payments. Описывает то, какие поля модели Payments будут участвовать в сериализации и десериализации.
   - Кастомизация сериализатора:
     - функция `def validate(self, data)` - валидация логики полей платежа: тип оплаты и выбор продукта (курс или урок). Это ранняя валидация еще в сериализаторе поэтому из контроллера PaymentsListCreateAPIView() я перенес сюда ряд проверок по выбранным Урокам и Курсам.
     Обоснование:
       - если ошибка есть в теле запроса - то лучше её находить на уровне сериализатора, а не контроллера.
       - так клиент (например, Postman или frontend) сразу получит 400 с объяснением, без лишней логики и без лишнего обращения к Stripe.

3) Сериализатор `CustomObtainPairSerializer(TokenObtainPairSerializer)` - кастомный класс-сериализатор токена наследующийся от TokenObtainPairSerializer, позволяющий вход по email.
   - Кастомизация сериализатора:
     - функция `def validate(self, attrs)` - позволяет принять email вместо username, найти пользователя по email, проверить пароль и вернуть токены.

## _Приложение "lms_system" (lms_system/serializers.py):_

1) Сериализатор `CourseSerializer(serializers.ModelSerializer)` - класс-сериализатор с использованием класса ModelSerializer для осуществления базовой сериализация в DRF на основе модели Course. Описывает то, какие поля модели Course будут участвовать в сериализации и десериализации.
   - Кастомизация сериализатора:
     - функция `get_count_lessons()` - определение количества уроков в курсе (запрос в БД для подсчёта связанных уроков). Учитываю кастомный ***related_name="lessons"*** в модели Lesson.
     - функция `get_is_subscribed()` - пороверяет подписан ли текущий пользователь на данный курс (True / False).
     - поле `lessons` - с помощью сериализатора для связанной модели *Lesson* (**LessonSerializer(many=True, read_only=True)**) вывод детальной информации по всем урокам курса, где:
       - ***many=True*** - параметр указывает, что это поле является связью "один ко многим" и может содержать несколько записей.
       - ***read_only=True*** - параметр указывает, что поле только для чтения и НЕ будет ожидаться на входе в запросах POST/PUT.
   - Валидация в сериализаторе:
     - для поля `description` определен валидатор `validators=[validate_domain_links]`.

2) Сериализатор `LessonSerializer(serializers.ModelSerializer)` - класс-сериализатор с использованием класса ModelSerializer для осуществления базовой сериализация в DRF на основе модели Lesson. Описывает то, какие поля модели Lesson будут участвовать в сериализации и десериализации.
   - Валидация в сериализаторе:
     - для полей `video_url` и `description` определен валидатор `validators = [YoutubeDomainValidator(fields=["video_url", "description"])` - реализовано так, чтоб мы в **class Meta** у сериализатора LessonSerializer могли в валидатор передавать сразу несколько полей которые нужно валидировать.

---

# <a id="title5">5. Описание валидации (validators)</a>

## _Приложение "lms_system" (lms_system/validators.py):_

1) Класс-валидатор `YoutubeDomainValidator` - для проверки допустимости домена в передаваемых пользователями URL. Разрешает только ссылки на YouTube (youtube.com и www.youtube.com).
   - Можно применять к различным типам полей (к URLField, к CharField, к TextField), что делает валидатор универсальным.
   - Используется регулярное выражение (***url_pattern = re.compile(r"https?://[^\s]+")***), что дает возможность поиска всех вхождений URL (http:// или https://) в передаваемом пользователе поле.

2) Функция-валидатор `validate_domain_links(field)` - для проверки допустимости домена в передаваемых пользователями URL. Разрешает только ссылки на YouTube (youtube.com и www.youtube.com).
   - Можно применять к различным типам полей (к URLField, к CharField, к TextField), что делает валидатор универсальным.
   - Используется регулярное выражение (***url_pattern = re.compile(r"https?://[^\s]+")***), что дает возможность поиска всех вхождений URL (http:// или https://) в передаваемом пользователе поле.

---

# <a id="title6">6. Описание контроллеров (views)</a>

## _Приложение "Users" (users/views.py):_

1) Класс-контроллер `CustomUserListAPIView(generics.ListAPIView)` - получение списка зарегистрированных пользователей.
   - на основе ***Generic*** - это компонент Django REST framework, который предоставляет набор готовых классов и миксинов для упрощения разработки RESTful API.
   - ***Доступно***: аутентифицированным пользователям.

2) Класс-контроллер `CustomUserCreateAPIView(generics.CreateAPIView)` - регистрация нового пользователя.
   - на основе ***Generic***.
   - ***Доступно***: всем пользователям.

3) Класс-контроллер `CustomUserRetrieveUpdateAPIView(generics.RetrieveUpdateAPIView)` - получение и редактирования профиля пользователя.
   - на основе ***Generic***.
   - ***Доступно***:
     - Просматривать профиль пользователя может любой авторизованный пользователь (только без персональных данных).
     - Редактировать профиль пользователя может только сам пользователь.
   - Кастомизация контроллера:
     - `get_serializer_context()` - передаёт request в сериализатор для дальнейшего анализа (например, в to_representation).
     - `check_object_permissions()` - проверяет права доступа к редактированию профиля.
       - ***Доступно***:
         - Просматривать (GET) может любой авторизованный пользователь.
         - Редактировать (PUT, PATCH) может только владелец профиля.

4) Класс-контроллер `CustomUserDestroyAPIView(generics.DestroyAPIView)` - удаление пользователя.
   - на основе ***Generic***.

5) Класс-контроллер `CustomTokenObtainPairView(TokenObtainPairView)` - класс-контроллер на основе TokenObtainPairView для возможности авторизации по email, так как я убрал username, которое было по умолчанию в DRF.
   - на основе ***TokenObtainPairView*** - базовый класс для получения JWT-токена.

6) Класс-контроллер `PaymentsListCreateAPIView(generics.ListCreateAPIView)` - класс-контроллер получения списка платежей и создания нового платежа:
   - на основе ***Generic***.
   - методы:
     - ***GET***: возвращает список всех платежей пользователя.
     - ***POST***: создаёт платёж на продукт (Course или Lesson) и генерирует ссылку на оплату через Stripe.
   - ВАЖНО:
     - Поля Stripe ("stripe_product_id", "stripe_price_id", "stripe_session_id", "payment_url") заполняются автоматом.
     - Пользователь подставляется из "request.user".получение списка платежей и создания нового платежа.
   - Кастомизация класса:
     - настроена фильтрация по курсу, уроку и оплате.
     - настроена сортировка по дате оплаты.
     - `get_queryset(self)` - метод ограничивает список платежей только платежами текущего пользователя при выполнении GET-запроса.
     - `perform_create(self, serializer)` - переопределение метода для создания платежа с интеграцией к платёжной системе Stripe:
       - создаётся продукт в Stripe (по .title в объекте продукта).
       - создаётся цена (в копейках).
       - создаётся сессия оплаты и сохраняется "payment_url".
       - все поля Stripe сохраняются в объект Payments.

7) Класс-контроллер `PaymentsRetrieveUpdateDestroyAPIView(generics.RetrieveUpdateDestroyAPIView)` - получение, обновление и удаление одного платежа.
   - на основе ***Generic***.

8) Класс-контроллер `StripePaymentStatusAPIView(APIView)` - класс-контроллер для проверки статуса оплаты по session_id (или payment_id).
   - на основе низкоуровневого ***APIView***.
   - Кастомизация класса:
     - `get(self, request, pk)` - метод возвращает статус платежа из Stripe.

## _Приложение "lms_system" (lms_system/views.py):_

1) Класс-контроллер `CourseViewSet(viewsets.ModelViewSet)` - автоматический CRUD для модели Course на основе ModelViewSet.
   - на основе ***ModelViewSet*** - это компонент Django REST для эффективного управления API-ресурсами и уменьшения объема кода.
   - Кастомизация класса:
     - `get_permissions()` - определяет права доступа к действиям с курсами в зависимости от типа запроса (action).
       - **create / list**:
         - Доступ разрешён только администраторам (IsAdminUser) и аутентифицированным (IsAuthenticated).
         - Владелец курса назначается автоматически (self.request.user).
       - **retrieve / update / partial_update**:
         - Владелец курса (IsOwner) может просматривать и редактировать свои курсы.
         - Модератор (IsModerator) может просматривать и редактировать любые курсы.
       - **destroy**:
         - Только владелец курса может удалить свой курс.
         - Администратор (IsAdminUser) может удалять любые курсы.
     - `perform_create(serializer)` - определяет и фиксирует владельцем Пользователя, который создал данный объект.
     - `perform_update(self, serializer)` - при обновлении курса запускает Celery-задачу для уведомления подписчиков с задержкой в 4 часа.

2) Класс-контроллер `LessonListCreateAPIView(generics.ListCreateAPIView)` - получение списка уроков и создание нового урока.
   - на основе ***Generic***.
   - Кастомизация класса:
     - `get_permissions()` - определяет права доступа к действиям со списком и созданием уроков:
        - **GET (список - List), POST (создание - Create)**:
          - Доступ разрешён только администраторам (IsAdminUser) и аутентифицированным (IsAuthenticated).
          - Владелец урока назначается автоматически (self.request.user).
     - `perform_create()` - метод:
       - Присваивает текущего авторизованного пользователя как владельца (owner) создаваемого объекта.
       - Запускает отложенную задачу по сбору списка подписчиков Курса, куда вошел этот новый Урок и отправка им писем с задержкой в 4 часа.

3) Класс-контроллер `LessonRetrieveUpdateDestroyAPIView(generics.RetrieveUpdateDestroyAPIView)` - получение, обновление и удаление одного урока.
   - на основе ***Generic***.
   - Кастомизация класса:
     - `get_permissions()` - определяет права доступа к действиям с конкретным уроком:
        - **GET (просмотр - Retrieve), PUT/PATCH (обновление - Update)**:
          - Владелец урока (IsOwner) может просматривать и редактировать свои уроки. 
          - Модератор (IsModerator) может просматривать и редактировать любые уроки.
        - **DELETE (удаление - Destroy)**:
          - Только владелец урока может удалить свой урок. 
          - Администратор (IsAdminUser) может удалять любые уроки.
     - `perform_update()` - запуск отложенной задачи по сбору списка подписчиков Курса, куда входит данный обновленный Урок и отправка им писем с задержкой в 4 часа.

4) Класс-контроллер `SubscriptionToggleAPIView(APIView)` - для установления подписки/отписки Пользователя на Курс:
   - на основе низкоуровневого ***APIView***.
   - Кастомизация класса:
     - `def post()` - метод для подписки/отписки Пользователя на Курс:
       - Получает пользователя из request.user (аутентифицированный пользователь).
       - Получает ID курса из request.data.
       - Проверяет, есть ли уже подписка на курс для этого пользователя.
         - если есть, то удаляет её (отписка).
         - если нет, то создаёт новую (подписка).

---

# <a id="title7">7. Описание прав доступов (permissions)</a>

## _Приложение "Users" (users/permissions.py):_

1) Класс `IsModerator(BasePermission)` - кастомный permission-класс, проверяющий, является ли пользователь модератором. Модераторы - это пользователи, которые входят в группу "Moderators". Им разрешается просматривать (GET) и редактировать (PUT, PATCH) объекты, но не создавать (POST) и не удалять (DELETE).
   - функция `has_permission()` - возвращает True, если пользователь аутентифицирован и состоит в группе "Moderators". Используется в контроллерах для ограничения доступа к операциям создания и удаления уроков/курсов.

2) Класс `IsOwner(BasePermission)` - кастомный permission-класс, проверяющий, является ли пользователь владельцем (owner). Им разрешается просматривать (GET), редактировать (PUT, PATCH) и удалять (DELETE) только свои объекты.
   - функция `has_permission()` - возвращает True, если пользователь является владельцем объекта. Используется в контроллерах для ограничения доступа к операциям с чужими уроками/курсами.

---

# <a id="title8">8. Описание пагинации (paginators)</a>

## _Приложение "lms_system" (lms_system/paginators.py):_

1) Класс `ListPagination(PageNumberPagination)` - общий пагинатор для вывода списка курсов (Course) и уроков (Lesson).
   - реализовано на основе `PageNumberPagination`, который разбивает данные на страницы на основе номера страницы.

---

# <a id="title9">9. Интеграция через API с платежной системой. Описание сервисных функций (services)</a>

## _Приложение "users" (users/services.py):_

1) Интеграция с платежной системой STRIPE (https://docs.stripe.com/api):

   - функция `create_stripe_product(paid_product)` - создание продукта по объекту модели (Course или Lesson) в платежной системе Stripe.
     - ***:param paid_course*** - это экземпляр модели (например, Course или Lesson), а Stripe_API ожидает:
       1) строку (str), чаще всего это название продукта (name), поэтому указываю "paid_product.title". 
       2) или словарь (dict), если передаем product_data.
     - ***:return:*** - для дальнейшего процесса формирования оплаты в return хватит одного product.id, если не нужны другие данные из ответа Stripe. Но, если нужно будет хранить в БД что-то ещё (например, product.url, product.name и т.д.), то нужно возвращать весь объект.

   - функция `create_stripe_price(product_id, payment_amount)` - создание цены продукта в платежной системе Stripe. Достаточно в функцию передать только product_id и payment_amount.
     - ***:param product_id*** - ID продукта из Stripe (строка).
     - ***:param payment_amount*** - цена продукта, которую потом нужно перевести в копейки обязательно.
     - ***:return:*** - для дальнейшего процесса формирования оплаты в return хватит одного price.id. Возвращаем объект только тогда, если нам нужно хранить какие-то другие поля (например, currency, unit_amount и т.д.)

   - функция `create_stripe_session(price_id)` - создание сессии для получения ссылки на оплату продукта. Достаточно в функцию передать только price_id, а остальное можно захардкодить (quantity=1 и т.д.) и потом изменить, когда появится у Пользователя возможность выбора количества оплачиваемых продуктов.
     - ***:param price_id*** - ID цены из Stripe (строка).
     - ***:return session.url, session.id*** - для дальнейшего процесса формирования оплаты в return хватит session.id и session.url.
       1) session.url - нужно отдать клиенту;
       2) session.id - нужно сохранить в модель для последующей проверки статуса (Session.retrieve)

   - функция `get_stripe_payment_status(session_id)` - получение статуса оплаты по session_id из Stripe.
     - ***:param session_id*** - ID сессии оплаты в Stripe.
     - ***:return session.url, session.id*** - строка со статусом оплаты (например, 'paid', 'unpaid' и т.д.).

## _Приложение "lms_system" (lms_system/services.py):_

1) Email-рассылка:

   - функция `send_course_update_email(course, emails_list)` - сервисная функция для отправки email-уведомлений подписчикам о том, что курс был обновлен.
     - ***:param course*** - объект Course, который обновился.
     - ***:param emails_list*** - список email-адресов получателей.

---

# <a id="title10">10. Вспомогательные функции</a>

## _Приложение "Users" (users/managers.py):_

1) Класс `CustomUserManager(BaseUserManager)` - кастомный менеджер для пользователя без поля username:
   - функция `create_user()` - создает и возвращает обычного пользователя.
   - функция `create_superuser()` - создает и возвращает суперпользователя.

---

# <a id="title11">11. Сигналы</a>

## _Приложение "lms_system" (lms_system/signals.py):_

1) Сигнал `update_course_timestamp()` - для обновления в объекте Course значения поля *updated_at*, если:
   - было выполнено обновление существующего объекта Lesson, который входит в данный Курс.
   - или был создан новый объект Lesson, который входит в данный Курс.
   - *Обработчик сигнала:*
     - ***@receiver(post_save, sender=Lesson)***
   - *Подключение сигналов в apps.py:*
     - ***def ready(self)***

---

# <a id="title12">12. Отложенные задачи</a>

## _Приложение "lms_system" (lms_system/tasks.py):_

1) Отложенная задача `task_send_course_update_email(course_id):` - собирает список подписчиков курса и вызывает отправку писем, если последнее обновление было более 4-х часов назад.
   - Шаги:
     1. Получает курс по ID.
     2. Находит всех подписчиков этого курса.
     3. Собирает список email-адресов.
     4. Если список не пустой - отправляет письма.
   - ***:param course_id*** - ID обновленного курса.
   - ***@shared_task(bind=True, max_retries=3)*** - устанавливает количество попыток отправки, если предыдущая отправка не сработала.

## _Приложение "users" (users/tasks.py):_

1) Периодическая задача `task_deactivate_inactive_users():` - проверяет пользователей по дате последнего входа по полю last_login и, если пользователь не заходил более месяца, блокировать его с помощью флага is_active.

---

# <a id="title13">13. Загрузка тестовых данных</a>

## _Директория проекта для различных данных (data/fixtures):_
1. Файл `courses.json` - фикстура с тестовыми данными для БД (таблица с данными курсов).
2. Файл `lessons.json` - фикстура с тестовыми данными для БД (таблица с данными уроков).
3. Файл `payments.json` - фикстура с тестовыми данными для БД (таблица с данными платежей).
4. Файл `groups.json` - фикстура с данными группы "Moderators" и добавления в нее набора прав доступов.

## _Приложение "lms_system" (lms_system/management/commands):_
1. `add_courses.py` - код кастомной команды по загрузке данных из `courses.json`.
2. `add_lessons.py` - код кастомной команды по загрузке данных из `lessons.json`.

## _Приложение "Users" (users/management/commands):_
1. `add_users.py` - код кастомной команды по cозданию тестовых пользователей через create_user().
2. `add_payments.py` - код кастомной команды по загрузке данных из `payments.json`.

---

# <a id="title14">14. Тестирование приложения</a>

## _Приложение "lms_system" (lms_system/tests.py):_

1) Команды для проверки покрытия тестами:
   ```
   coverage run manage.py test
   coverage report
   coverage html
   ```

2) Класс `LessonAPITestCase(APITestCase)` - тесты, которые будут проверять корректность работы CRUD для уроков (Lesson):
   - `test_create_lesson` - тест создания нового урока через POST-запрос.
   - `test_read_list_lessons` - тест получения списка уроков через GET-запрос.
   - `test_update_lesson` - тест частичного обновления существующего урока через PATCH-запрос.
   - `test_delete_lesson` - тест удаления существующего урока через DELETE-запрос.
   - `test_401_unauthenticated_create_lesson` - тест создания урока неавторизованным пользователем (401 - Unauthorized).
   - `test_403_forbidden_update_lesson_by_stranger` - тест проверки, что другой пользователь не может редактировать чужой урок (403 - Forbidden).
   - `test_invalid_video_url` - тест проверки, что ссылки кроме YouTube вызывают ошибку валидации.

3) Класс `SubscriptionToggleAPITestCase(APITestCase)` - тесты, которые будут проверять функционал работы подписки на обновления курса:
   - `test_user_subscribe_to_course` - тест подписки пользователя на курс.
   - `test_user_unsubscribe_from_course` - тест отписки пользователя с курса.

---

# <a id="title15">15. Получение ключей для локального запуска. Описание файла .env.example</a> 
1. Создайте файл .env в корне проекта из копии подготовленного файла `.env.example`, в котором описаны названия всех переменных, необходимых для работы приложения.
2. Замените значения переменных реальными данными.
3. В модуле `settings.py` существует секретный ключ `SECRET_KEY`, который рекомендуется в целях безопасности хранить в тайне:
4. Файл .env должен содержать данные:
```dotenv
# Настройки секретного ключа проекта django в config/settings.py
#Django рекомендует в целях безопасности хранить секретный ключ, используемый в продакшене, в тайне!
SECRET_KEY_FOR_PROJECT=secret_key_here

# Настройки дебага.
# В settings.py дебаг должен быть описан так: DEBUG = True if os.getenv('DEBUG') == 'True' else False
DEBUG=

# Настройки БД проекта django в config/settings.py
DATABASE_NAME=
DATABASE_USER=
DATABASE_PASSWORD=
DATABASE_HOST=
DATABASE_PORT=

# Секретный ключ для платежного сервиса Stripe
SECRET_KEY_FOR_STRIPE=secret_key_here

# URL-адрес брокера сообщений (Redis)
CELERY_BROKER_URL=

# URL-адрес брокера результатов - хранилище результатов выполнения задаx (использую тот же Redis)
CELERY_RESULT_BACKEND=

# Настройка SMTP-сервера Яндекса для отправки писем пользователям:
YANDEX_EMAIL_HOST_USER=
YANDEX_EMAIL_HOST_PASSWORD=password_here

# 1) ЧТО ЭТО?
# Если используется нестандартный порт (например, http://127.0.0.1:8080/admin/ вместо http://127.0.0.1:8000/admin/),
# то Django будет не доверять адресу http://127.0.0.1:8080/admin/, так как источник будет не совпадать с
# доверенным доменом из ALLOWED_HOSTS или CSRF_TRUSTED_ORIGINS и выдаст 403 CSRF verification failed.
# Чтоб исключить ошибку нужно добавить параметр CSRF_TRUSTED_ORIGINS в settings.py и указывать в нем список
# доверенных доменов с портами
# 2) ДОП ПОЯСНЕНИЕ: 
# Django проверяет конфигурацию, и в CSRF_TRUSTED_ORIGINS должен быть СПИСОК и без пустых некорректных 
# данных, поэтому если не хардкодить тут и выносить в .ENV , то нужно писать код для создания списка без пустых
# значений в конце.
CSRF_TRUSTED_ORIGINS=http://хост:8080
```

---

# <a id="title16">16. Получение ключей для запуска через DOCKER. Описание файла .env.docker.example</a> 
1. Создайте файл .env.docker в корне проекта из копии подготовленного файла `.env.docker.example`, в котором описаны названия всех переменных, необходимых для работы приложения.
2. Замените значения переменных реальными данными.
3. В модуле `settings.py` существует секретный ключ `SECRET_KEY`, который рекомендуется в целях безопасности хранить в тайне:
4. Файл .env.docker должен содержать данные:
```dotenv
# Создайте файл .env.docker из копии этого файла и замените значения переменных реальными данными для запуска
# приложения через DOCKER

# Настройки секретного ключа проекта django в config/settings.py
#Django рекомендует в целях безопасности хранить секретный ключ, используемый в продакшене, в тайне!
SECRET_KEY_FOR_PROJECT=secret_key_here

# Настройки дебага. В settings.py дебаг должен быть описан так: DEBUG = True if os.getenv('DEBUG') == 'True' else False
DEBUG=

# Настройки БД (ВАЖНО!!! В Docker DATABASE_HOST = db)
# Название базы для приложения:
# 1) Postgres (для контейнера db)
POSTGRES_DB=
POSTGRES_USER=
POSTGRES_PASSWORD=

# 2) Django (чтобы settings.py подхватывал те же значения)
DATABASE_NAME="${POSTGRES_DB}"
DATABASE_USER="${POSTGRES_USER}"
DATABASE_PASSWORD="${POSTGRES_PASSWORD}"
DATABASE_HOST=db
DATABASE_PORT=

# Секретный ключ для платежного сервиса Stripe
SECRET_KEY_FOR_STRIPE=secret_key_here

# URL-адрес брокера сообщений (Redis) (ВАЖНО!!! В Docker Redis = redis)
CELERY_BROKER_URL=redis://redis:6379/0

# URL-адрес брокера результатов - хранилище результатов выполнения задач (ВАЖНО!!! В Docker Redis = redis)
CELERY_RESULT_BACKEND=redis://redis:6379/0

# Настройка SMTP-сервера Яндекса для отправки писем пользователям:
YANDEX_EMAIL_HOST_USER=
YANDEX_EMAIL_HOST_PASSWORD=password_here

# Имя пользователя DockerHub с которым связан наш репозитория проекта на GitHub через настройки секретного ключа там
DOCKER_HUB_USERNAME=

# 1) ЧТО ЭТО?
# Если используется нестандартный порт (например, http://127.0.0.1:8080/admin/ вместо http://127.0.0.1:8000/admin/),
# то Django будет не доверять адресу http://127.0.0.1:8080/admin/, так как источник будет не совпадать с
# доверенным доменом из ALLOWED_HOSTS или CSRF_TRUSTED_ORIGINS и выдаст 403 CSRF verification failed.
# Чтоб исключить ошибку нужно добавить параметр CSRF_TRUSTED_ORIGINS в settings.py и указывать в нем список
# доверенных доменов с портами
# 2) ДОП ПОЯСНЕНИЕ: 
# Django проверяет конфигурацию, и в CSRF_TRUSTED_ORIGINS должен быть СПИСОК и без пустых некорректных 
# данных, поэтому если не хардкодить тут и выносить в .ENV , то нужно писать код для создания списка без пустых
# значений в конце.
CSRF_TRUSTED_ORIGINS=http://хост:8080
```

---

# <a id="title17">17. Описание файла .flake8</a> 
```angelscript
[flake8]
max-line-length = 119
ignore = E203, W503
exclude = .git, __pycache__, venv, .venv, */migrations/*,
```

---

# <a id="title18">18. Описание файла mypy.ini</a> 
```ini
# Настроил mypy для Django, указав путь к settings.py.
# Это нужно было чтоб убрать ошибки проверки mypy
# из-за того, что он не распознавал phonenumber_field,
# так как у phonenumber_field нет type stubs.
[mypy]
plugins = mypy_django_plugin.main

# Указываем настройки для плагина Django.
[mypy.plugins.django-stubs]
django_settings_module = config.settings

# Пробовал игнорировать phonenumber_field в mypy.ini,
# но это не сработало, и поэтому пришлось добавить
# в код (users/models.py) вот это "# type: ignore"
# на импорт PhoneNumberField, и ошибка исчезла.
[mypy-phonenumber_field.*]
ignore_missing_imports = True
```

---

# <a id="title19">19. Документация к API</a> 
1. ***Swagger UI*** по адресу: http://127.0.0.1:8000/swagger/
2. ***Redoc*** по адресу: http://127.0.0.1:8000/redoc/

---

# <a id="title20">20. Локальная установка проекта</a>
1. Клонируйте репозиторий:
   ```commandline
   git clone https://github.com/MaksimLakovich/LMS-system.git
   ```
2. Установите зависимости:
   ```commandline
   poetry install
   ```
3. Заполните файл `.env` по примеру `.env.example`

---

# <a id="title21">21. Установка и запуск проекта на сервере (через Docker и Nginx)</a>

1. Клонируйте репозиторий:
    ```commandline
    git clone https://github.com/MaksimLakovich/LMS-system.git
    cd LMS-system.git
    ```

2. Создайте файл окружения ***.env.docker*** (на основе примера *.env.docker.example*) и заполните его реальными данными:
    ```commandline
    cp .env.docker.example .env.docker
    nano .env.docker
    ```
   
3. Соберите и запустите контейнеры:
    ```commandline
    docker-compose up -d --build
    ```
   
4. Выполните миграции и соберите статику (если они ещё не применялись):
    ```commandline
    docker-compose exec web python manage.py migrate
    docker-compose exec web python manage.py collectstatic --noinput
    ```
   
5. После успешного запуска приложение будет доступно по IP-адресу вашей ВМ на порту 80: `http://<ваш-ip>`

---

# <a id="title22">22. Автоматический деплой через GitHub Actions</a> 

Репозиторий настроен на автоматический деплой через GitHub Actions.

1. При каждом push в ветку main происходит:
   - запуск линтера (flake8),
   - запуск тестов (с использованием SQLite),
   - сборка Docker-образа,
   - публикация образа в Docker Hub,
   - деплой на удалённый сервер (IP: 158.160.199.127 - ***ДЛЯ ИНФО!* В проекте используется динамический IP-адрес поэтому может измениться со временем!**).
2. Для работы пайплайна настроены секреты в GitHub:
   - для публикации образов:
     - DOCKER_HUB_USERNAME
     - DOCKER_HUB_ACCESS_TOKEN
   - для деплоя на сервер:
     - SSH_USER
     - SERVER_IP
     - SSH_KEY

После успешного выполнения пайплайна приложение автоматически обновляется и доступно по адресу:

http://158.160.199.127:8080/admin/